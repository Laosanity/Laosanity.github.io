<a id="rocket" href="#top" class="show"></a><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description" content="Personal Blog Site"/><title>Quick Walk through Recommender Systems and Memory-based Collaborative Filtering | 斯是陋室</title><!--+get_resource("blog_basic.css")--><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/pure-min.css"/><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"/><link rel="stylesheet" type="text/css" href="/css/highlight.css"/><link rel="stylesheet" type="text/css" href="/css/style.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Quick Walk through Recommender Systems and Memory-based Collaborative Filtering</h1><a id="logo" href="/">斯是陋室</a><p class="description"></p></div><div id="nav-menu"><a href="/" class="current">Home</a><a href="/archives">Archive</a><a href="/" class="current">About</a><a href="/atom.xml">RSS</a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">Quick Walk through Recommender Systems and Memory-based Collaborative Filtering</h1><div class="post-meta">October 23, 2015</div><span data-thread-key="2015/10/23/Quick Walk through Recommender systems and Memory-based Collaborative Filtering/" class="ds-thread-count"></span><div class="post-content"><h1 id="What_can_Recommender_System_provide?">What can Recommender System provide?</h1><p>Imagine such scenario in real world: As a programmer, you are finding some books about mobile development on an online bookshop. However, overwhelmed by such numerous kinds of books, you may already get confused and have no idea which one to choose. And now what you really need maybe some suggestions from your programer friends who has bought or read some of them. Because you know that your friends and you are same kind of people, your taste are similar,  so you have reasons to trust your friends’ suggestions.</p>
<p>Based on this behaviour, people started to apply  recommender system to online-shop. What happened after that? Say you like pop music and you want to try out latest pop musics online. From a recommend list you will have more possibility to find the music you want. And you no longer need to try it one by one in the latest-release list, which means you no longer have to face too much useless information and you save your time. Actually it makes more sence for e-commercial bussness, recommender systems provides higher quality advertiments services. Just look at those advertisements posted on most of online-shop websites, they are more intellegent and seems know your taste.</p>
<h1 id="Walk_through_Recommender_System">Walk through Recommender System</h1><p>Then let’s talk about recommender systems and look at how they work.<br>The core technology used in recommender systems is the automated information filtering algorithm, more accurately, collaborative filtering, which firstly was mentioned in paper [1] by GroupLens research team. And the problem for collaborative filtering algorithm to solve is ￼ [1]:</p>
<blockquote>
<p>the problem of automated collaborative filtering is to predict how well a user will like an item that he has not rated.</p>
</blockquote>
<p>As defined above, the key to the problem is the prediction for rating-values, and the final purpose of this algorithm is the prediction.</p>
<p>Before making prediction, we need measures on how much a person like or prefer a thing or an item? In [1], GroupLen defined two kinds of measures, explicit measures and implicit measures. Explicit measures can be inferred from avaliable data on user activity, such as rating. As for implicit measures, we can derive it from raw data on servers like purchase records, time spent reading or web logs. With those rating data, a prediciton engine can start to work. Commonly all those data are pictured as a big matrix of users vs. items, with each cell representing a user’s rating on an item. Now the problem left for prediction engine is to fill in the blank specified cells, and returns the list of top-n predicted items to users. </p>
<p>In [2], collaborative algorithms ara classified into two main kinds of algorithm: Model-based and Memory-based. Model-based algorithms provide a prediction model by applying machine learning methods like Bayesian network or clustering. Algorithms in this category utilize a user’s ratings on other items as the input of model and return the predict ratings on this item for the user. Memory-based algorithms utilize the whole user-item data set to make prediciton, by employing statistical techniques (i.e. item-similarity and value-weighting). </p>
<h1 id="User-based_Algorithm_vs-_Item-based_Algorithm">User-based Algorithm vs. Item-based Algorithm</h1><p>In this post I only talk about Memory-based algorithms. Before that, there are some statistical methods on calculating similarity between items (or persons) you need to know first.</p>
<ol>
<li>Pearson/Spearman. Discrete ratings -> spearman. Continuous ratings -> pearson. Use it depends on which kind of your rating value is.</li>
<li>Eludien distance. This is much easier to implement.</li>
<li>Adjusted-cosine-similarity. Suitable for calculating similarity between items.</li>
</ol>
<p>GroupLens came up with this algorithm (also called neighbor-based) in [1]. This method can be simplified as following several steps:</p>
<blockquote>
<ol>
<li>Weight all users with repect to similarity with the active user.</li>
<li>Select a subset of users to use as a set of predictors.</li>
<li>Normalize ratings and compute a prediction from a weighted combination of selected neighbors’ ratings.</li>
</ol>
</blockquote>
<p>But there still are challenges of user-based algorithm we have to face. Challenges for user-based algorithm also are mentioned in [2]. </p>
<ol>
<li><strong>Sparsity</strong>. Let’s recall basic steps of user-based algorithm. To acheive more accurate prediction, a dense item-user matrix is important, which provides more coverage on items and higher accuracy on user similarity. However in practice, it’s difficult to obtain such dence data especially on the start of a new system. </li>
<li><strong>Scalability</strong>. From performance perspective, user-based algorithm requires computations on the scale of both users and items, which is not a small cost. In practice, recommender systems require real-time response to large number of users. Therefore this algorithm may not be able to handle such large scale of data if applied to commercial systems.</li>
</ol>
<p>In paper [2] GroupLens came up with a new filtering model based on item records, also called item-based collaborative filtering.</p>
<blockquote>
<ol>
<li>Calculate the similarity between items.</li>
<li>Calculate the weighted sum. Sum up all ratings values of reted items from a user, and each value is weighted by the similarity value between the rates items and the item to predict.</li>
</ol>
<p>Step2: in [2], author mentioned two techniques. Another one is Regression. </p>
</blockquote>
<p>For E-Commerce site of large scale,  user-based CF systems need calculate user-user similarity at higher frequency, which turns out be to the performance bottleneck and not suitable for real-time response. Different from user-based CF systems, item-based CF systems work on item-item scope. Unlike users data, items data seems more static, which leads the idea of precomputing the item similarity. With this idea, we can precompute all item similarity and store them in a quick table for retrieving the required similarity values. As a result, item-based CF system s can be faster than user-based CF systems especially working on a site of large scale.</p>
<p>In [2], authors promote a model-based method of similarity computation:</p>
<blockquote>
<p>For  a user u on item i, out algorithm first retrieves the precomputed k most similar items corresponding to the target item i. Then it looks how many of those k items were purchased by the user u, based on this intersection then the prediction is computed using basic item-based CF algorithm</p>
</blockquote>
<p>A quality-performance trade-off here: For a better quality result, precomputed model of larger scale is needed, which leads worse performance instead. in [2] GroupLens hypothesized that this model-based approach will provide reasonably good prediction quality with even a small model size. They performed experiments to validate their hypothesis and you can read paper [2].</p>
<h1 id="Challenges_of_collaborative_filtering">Challenges of collaborative filtering</h1><p>However in real word, CF system faces following chanllenges:</p>
<ol>
<li>Cold Start. As mentioned above, this problem causes data sparsity.</li>
<li>Shiling Attack. Anybody can rates products. And people may give a positive rating for the products of their competitors.</li>
<li>Scalability. The complexity n grows with the scale of customers or items. The number n is quiet big for CF systems in modern sites.</li>
<li>Diversity and the Long Tail. Because collaborative filters recommend products based on past sales or ratings, they cannot usually recommend products with limited historical data. This can create a rich-get-richer effect for popular products. This bias toward popularity can prevent what are otherwise better consumer-product matches. </li>
</ol>
<p><em>Refs</em></p>
<p><em>[1] GroupLens, An algorithm for performing collabrative filtering.</em></p>
<p><em>[2] GroupLens, Item-Based Collaborative Filtering Recommendation Algorithms.</em></p>
<p><em>[3] Toby Segaran, Programming Collective Intelligence.</em></p>
<p>_[4] wiki: <a href="http://en.wikipedia.org/wiki/Collaborative\_filtering._" target="_blank" rel="external">http://en.wikipedia.org/wiki/Collaborative\_filtering._</a></p>
</div><div class="tags"><a href="/tags/algorithm/">algorithm</a><a href="/tags/artificial-intelligence/">artificial intelligence</a></div><div class="categories">Categorized in<a href="/categories/Collective-Intelligence/">Collective Intelligence</a></div><div class="page-navigator"><a href="/2015/01/27/-T-Creating-a-wildly-successful-blog/" class="next">Next</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title">Categories</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Collective-Intelligence/">Collective Intelligence</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Thoughts/">Thoughts</a></li></ul></div><div class="widget"><div class="widget-title">Tags</div><div class="tagcloud"><a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/artificial-intelligence/" style="font-size: 15px;">artificial intelligence</a></div></div><div class="widget"><div class="widget-title">Recent</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/10/23/Quick Walk through Recommender systems and Memory-based Collaborative Filtering/">Quick Walk through Recommender Systems and Memory-based Collaborative Filtering</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/27/-T-Creating-a-wildly-successful-blog/">创建一个成功的个人博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/23/-e6-b1-82-e5-b9-82-e7-ae-97-e6-b3-95/">求幂算法的延伸运用</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/22/object-inheritence-in-javascript/">Object Inheritence in Javascript</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/21/javascript-memory-management/">Javascript Memory Management</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/18/javascript-read-notes/">Javascript Read Notes</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/14/kmp-knuth-morris-pratt/">KMP (Knuth-Morris-Pratt)</a></li></ul></div><div class="widget"><div class="widget-title">Blogroll</div><ul><a href="http://example1.com/" title="site-name 1" target="_blank" rel="external">site-name 1</a></ul><ul><a href="http://example2.com/" title="site-name 2" target="_blank" rel="external">site-name 2</a></ul><ul><a href="http://example3.com/" title="site-name 3" target="_blank" rel="external">site-name 3</a></ul></div></div></div></div><script src="/js/highlight.pack.js" type="text/javascript"></script><script>hljs.initHighlightingOnLoad();
</script><div id="footer">© <a href="/" real="nofollow">斯是陋室. </a>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>Theme by<a rel="nofollow" target="_blank" href="https://chopstack.com">Cho</a></div></div></body><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>$(document).ready(function() {
  $("img").wrap(function() {
    if ($(this).hasClass('nofancybox')) return;
    return '<a href="' + $(this).attr("src") + '" rel="group" />'});
});</script><script>$(document).ready(function() {
  $("a[href$='.jpg'],a[href$='.png'],a[href$='.gif']").attr('rel', 'gallery').fancybox({
   helpers : {
   title: { type: 'inside'}
   },
   afterLoad: function(){
   this.title = this.title + ' ' + $(this.element).find('img').attr('alt');
   }
 });
});
</script></html>