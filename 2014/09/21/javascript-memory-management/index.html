<a id="rocket" href="#top" class="show"></a><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description" content="Personal Blog Site"/><title>Javascript Memory Management | 斯是陋室</title><!--+get_resource("blog_basic.css")--><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/pure-min.css"/><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"/><link rel="stylesheet" type="text/css" href="/css/highlight.css"/><link rel="stylesheet" type="text/css" href="/css/style.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Javascript Memory Management</h1><a id="logo" href="/">斯是陋室</a><p class="description"></p></div><div id="nav-menu"><a href="/" class="current">首页</a><a href="/archives">归档</a><a href="/" class="current">关于</a><a href="/atom.xml">订阅</a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">Javascript Memory Management</h1><div class="post-meta">September 21, 2014</div><span data-thread-key="2014/09/21/javascript-memory-management/" class="ds-thread-count"></span><div class="post-content"><h1 id="Introduction">Introduction</h1><p>Low-level languages, like C, have low-level memory management primitives like <code>malloc()</code> and <code>free()</code>. On the other hand, JavaScript values are allocated when things (objects, strings, etc.) are created and “automatically” free’d when they are not used anymore. The latter process is called <em>garbage collection</em>. This “automatically” is a source of confusion and gives JavaScript (and high-level languages) developers the impression they can decide not to care about memory management. This is a mistake.</p>
<h1 id="Memory_life_cycle">Memory life cycle</h1><p>Regardless of the programming language, memory life cycle is pretty much always the same:</p>
<p>The first and second parts are explicit in all languages. The last part is explicit in low-level languages, but is mostly implicit in high-level languages like JavaScript.</p>
<h2 id="Allocation_in_JavaScript">Allocation in JavaScript</h2><h3 id="Value_initialization">Value initialization</h3><p>In order not to bother the programmer with allocations, JavaScript does it alongside with declaring values.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// allocates memory for a number</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>; <span class="comment">// allocates memory for a string </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// allocates memory for an object and contained values</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (like object) allocates memory for the array and </span></span><br><span class="line"><span class="comment">// contained values</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">"abra"</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="comment">// allocates a function (which is a callable object)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function expressions also allocate an object</span></span><br><span class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Allocation_via_function_calls">Allocation via function calls</h3><p>Some function calls result in object allocation.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// allocates a DOM element</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure><br>Some methods allocate new values or objects:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s.substr(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 is a new string</span></span><br><span class="line"><span class="comment">// Since strings are immutable value, </span></span><br><span class="line"><span class="comment">// JavaScript may decide to not allocate memory, </span></span><br><span class="line"><span class="comment">// but just store the [0, 3] range.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">"ouais ouais"</span>, <span class="string">"nan nan"</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = [<span class="string">"generation"</span>, <span class="string">"nan nan"</span>];</span><br><span class="line"><span class="keyword">var</span> a3 = a.concat(a2); </span><br><span class="line"><span class="comment">// new array with 4 elements being</span></span><br><span class="line"><span class="comment">// the concatenation of a and a2 elements</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Using_values">Using values</h2><p>Using value basically means reading and writing in allocated memory. This can be done by reading or writing the value of a variable or an object property or even passing an argument to a function.</p>
<h2 id="Release_when_the_memory_is_not_needed_anymore">Release when the memory is not needed anymore</h2><p>Most of memory management issues come at this phase. The hardest task here is to find when “the allocated memory is not needed any longer”. It often requires for the developer to determine where in the program such piece of memory is not needed anymore and free it.</p>
<p>High-level languages embed a piece of software called “garbage collector” whose job is to track memory allocation and use in order to find when a piece of allocated memory is not needed any longer in which case, it will automatically free it. This process is an approximation since the general problem of knowing whether some piece of memory is needed is <a href="http://en.wikipedia.org/wiki/Decidability_%28logic%29" target="_blank" rel="external">undecidable</a> (can’t be solved by an algorithm).</p>
<h1 id="Garbage_collection">Garbage collection</h1><p>As stated above the general problem of automatically finding whether some memory “is not needed anymore” is undecidable. As a consequence, garbage collections implement a restriction of a solution to the general problem. This section will explain the necessary notions to understand the main garbage collection algorithms and their limitations.</p>
<h2 id="References">References</h2><p>The main notion garbage collection algorithms rely on is the notion of <em>reference</em>. Within the context of memory management, an object is said to reference another object if the former has an access to the latter (either implicitly or explicitly). For instance, a JavaScript object has a reference to its <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain" target="_blank" rel="external">prototype</a> (implicit reference) and to its properties values (explicit reference).</p>
<p>In this context, the notion of “object” is extended to something broader than regular JavaScript objects and also contains function scopes (or the global lexical scope)</p>
<h2 id="Reference-counting_garbage_collection">Reference-counting garbage collection</h2><p>This is the most naive garbage collection algorithm. This algorithm reduces the definition of “an object is not needed anymore” to “an object has no other object referencing to it”. An object is considered garbage collectable if there is zero reference pointing at this object.</p>
<h3 id="Example">Example</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">  a: &#123;</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 2 objects are created. One is referenced by the other as one of its property.</span></span><br><span class="line"><span class="comment">// The other is referenced by virtue of being assigned to the 'o' variable.</span></span><br><span class="line"><span class="comment">// Obviously, none can be garbage-collected</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// the 'o2' variable is the second thing that </span></span><br><span class="line">            <span class="comment">// has a reference to the object</span></span><br><span class="line">o = <span class="number">1</span>;      <span class="comment">// now, the object that was originally in 'o' has a unique reference</span></span><br><span class="line">            <span class="comment">// embodied by the 'o2' variable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oa = o2.a; <span class="comment">// reference to 'a' property of the object.</span></span><br><span class="line">               <span class="comment">// This object has now 2 references: one as a property, </span></span><br><span class="line">               <span class="comment">// the other as the 'oa' variable</span></span><br><span class="line"></span><br><span class="line">o2 = <span class="string">"yo"</span>; <span class="comment">// The object that was originally in 'o' has now zero</span></span><br><span class="line">           <span class="comment">// references to it. It can be garbage-collected.</span></span><br><span class="line">           <span class="comment">// However what was its 'a' property is still referenced by </span></span><br><span class="line">           <span class="comment">// the 'oa' variable, so it cannot be free'd</span></span><br><span class="line"></span><br><span class="line">oa = <span class="literal">null</span>; <span class="comment">// what was the 'a' property of the object originally in o </span></span><br><span class="line">           <span class="comment">// has zero references to it. It can be garbage collected</span></span><br></pre></td></tr></table></figure>
<h3 id="Limitation_:_cycles">Limitation : cycles</h3><p>This naive algorithm has the limitation that if objects reference one another (and form a cycle), they may be “not needed anymore” and yet not garbage collectable.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.a = o2; <span class="comment">// o references o2</span></span><br><span class="line">  o2.a = o; <span class="comment">// o2 references o</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"azerty"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br><span class="line"><span class="comment">// Two objects are created and reference one another thus creating a cycle.</span></span><br><span class="line"><span class="comment">// They will not get out of the function scope after the function call, so they</span></span><br><span class="line"><span class="comment">// are effectively useless and could be free'd.</span></span><br><span class="line"><span class="comment">// However, the reference-counting algorithm considers that since each of both</span></span><br><span class="line"><span class="comment">// object is referenced at least once, none can be garbage-collected.</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Real_life_example">Real life example</h3><p>Internet Explorer 6, 7 are known to have a reference-counting garbage collector for DOM objects. For them, a common pattern is known to generate memory leaks systematically:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// The div has a reference to the event handler via its 'onclick' property</span></span><br><span class="line"><span class="comment">// The handler also has a reference to the div since the 'div' variable can </span></span><br><span class="line"><span class="comment">// be accessed within the function scope. This cycle will cause both objects </span></span><br><span class="line"><span class="comment">// not to be garbage-collected and thus a memory leak.</span></span><br></pre></td></tr></table></figure>
<h2 id="Mark-and-sweep_algorithm">Mark-and-sweep algorithm</h2><p>This algorithm reduces the definition of “an object is not needed anymore” to “an object is unreachable”.</p>
<p>This algorithm assumes the knowledge of a set of objects called <em>roots</em> (In JavaScript, the root is the global object). Periodically, the garbage-collector will start from these roots, find all objects that are referenced from these roots, then all objects referenced from these, etc. Starting from the roots, the garbage collector will thus find all <em>reachable</em> objects and collect all non-reachable objects.</p>
<p>This algorithm is better than the previous one since “an object has zero reference” leads to this object being unreachable. The opposite is not true as we have seen with cycles.</p>
<p>As of 2012, all modern browsers ship a mark-and-sweep garbage-collector. All improvements made in the field of JavaScript garbage collection (generational/incremental/concurrent/parallel garbage collection) over the last few years are implementation improvements of this algorithm, but not improvements over the garbage collection algorithm itself nor its reduction of the definition of when “an object is not needed anymore”.</p>
<h3 id="Cycles_are_not_a_problem_anymore">Cycles are not a problem anymore</h3><p>In the first above example, after the function call returns, the 2 objects are not referenced anymore by something reachable from the global object. Consequently, they will be found unreachable by the garbage collector.</p>
<p>The same thing goes with the second example. Once the div and its handler are made unreachable from the roots, they can both be garbage-collected despite referencing each other.</p>
<h3 id="Limitation:_objects_need_to_be_made_explicitly_unreachable">Limitation: objects need to be made explicitly unreachable</h3><p>Although this is marked as a limitation, it is one that is rarely reached in practice which is why no one usually cares that much about garbage collection.</p>
<p>from: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management</a></p>
</div><div class="tags"><a href="/tags/javascript/">javascript</a></div><div class="categories">分类于<a href="/categories/Javascript/">Javascript</a></div><div class="page-navigator"><a href="/2014/09/22/object-inheritence-in-javascript/" class="pre">上一页</a><a href="/2014/09/18/javascript-read-notes/" class="next">下一页</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Collective-Intelligence/">Collective Intelligence</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Thoughts/">Thoughts</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/artificial-intelligence/" style="font-size: 15px;">artificial intelligence</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/10/23/Quick Walk through Recommender systems and Memory-based Collaborative Filtering/">Quick Walk through Recommender Systems and Memory-based Collaborative Filtering</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/27/-T-Creating-a-wildly-successful-blog/">创建一个成功的个人博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/23/-e6-b1-82-e5-b9-82-e7-ae-97-e6-b3-95/">求幂算法的延伸运用</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/22/object-inheritence-in-javascript/">Object Inheritence in Javascript</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/21/javascript-memory-management/">Javascript Memory Management</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/18/javascript-read-notes/">Javascript Read Notes</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/14/kmp-knuth-morris-pratt/">KMP (Knuth-Morris-Pratt)</a></li></ul></div><div class="widget"><div class="widget-title">友情链接</div><ul><a href="http://example1.com/" title="site-name 1" target="_blank" rel="external">site-name 1</a></ul><ul><a href="http://example2.com/" title="site-name 2" target="_blank" rel="external">site-name 2</a></ul><ul><a href="http://example3.com/" title="site-name 3" target="_blank" rel="external">site-name 3</a></ul></div></div></div></div><script src="/js/highlight.pack.js" type="text/javascript"></script><script>hljs.initHighlightingOnLoad();
</script><div id="footer">© <a href="/" real="nofollow">斯是陋室. </a>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>Theme by<a rel="nofollow" target="_blank" href="https://chopstack.com">Cho</a></div></div></body><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>$(document).ready(function() {
  $("img").wrap(function() {
    if ($(this).hasClass('nofancybox')) return;
    return '<a href="' + $(this).attr("src") + '" rel="group" />'});
});</script><script>$(document).ready(function() {
  $("a[href$='.jpg'],a[href$='.png'],a[href$='.gif']").attr('rel', 'gallery').fancybox({
   helpers : {
   title: { type: 'inside'}
   },
   afterLoad: function(){
   this.title = this.title + ' ' + $(this.element).find('img').attr('alt');
   }
 });
});
</script></html>