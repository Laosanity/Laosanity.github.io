<a id="rocket" href="#top" class="show"></a><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description" content="Personal Blog Site"/><title>求幂算法的延伸运用 | 斯是陋室</title><!--+get_resource("blog_basic.css")--><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/pure-min.css"/><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"/><link rel="stylesheet" type="text/css" href="/css/highlight.css"/><link rel="stylesheet" type="text/css" href="/css/style.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">求幂算法的延伸运用</h1><a id="logo" href="/">斯是陋室</a><p class="description"></p></div><div id="nav-menu"><a href="/" class="current">首页</a><a href="/archives">归档</a><a href="/" class="current">关于</a><a href="/atom.xml">订阅</a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">求幂算法的延伸运用</h1><div class="post-meta">September 23, 2014</div><span data-thread-key="2014/09/23/-e6-b1-82-e5-b9-82-e7-ae-97-e6-b3-95/" class="ds-thread-count"></span><div class="post-content"><h2 id="求幂算法">求幂算法</h2><p>这篇日志我想展示一个非常基本的用以幂次计算的思路，借助这个思路我们可以更好理解一些抽象的概念，譬如半群（Semigroup）和含幺半群（Monoids）。</p>
<p>幂次计算中有一个有名的算法（即计算如： Xˆn ），即Donald Knuth在《计算机程序艺术》（ TAOCP ）所曾提到的那个算法。接下来我们先聊聊这个算法。</p>
<p>最直白的想法就是把X乘上n遍，当然有个算法要比这个快得多，这个算法通常被称为binary method、powering ladder或者repeated-squaring algorithm。</p>
<p>举个例子，计算2ˆ23 。在这个算法中，这个算式会被转化成：2ˆ(10111)，其中 (10111) 则是23的二进制表达。之后就是扫描一遍，遇到0计算X二次方，遇到1则乘以X。</p>
<p>这个方法有个问题，那就是这个算法是从左到右扫描，而对于计算机来说另一个方向来做更容易。因此Knuth提出了另一个算法。</p>
<p>以下给出这个算法的实现代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">power</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( n &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">    t = n % <span class="number">2</span>;</span><br><span class="line">    n = <span class="built_in">Math</span>.floor(n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> ( t === <span class="number">1</span> ) &#123;</span><br><span class="line">      res *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    x *= x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<p>这个方程有两个整数参数 x 和 n， 返回x的n次方结果。</p>
<p>首先这个方程内辉县设置一个辅助的变量y，初值为1，当然这个1可以看做是相乘操作的标示。</p>
<p>随后，程序开始扫描n的二进制表达值。只要发现是1则乘上x，而在每次循环时都要运算x次方的值。当n为0时，代表扫描完毕，得到结果。</p>
<p>那么这个算法背后的启发点是什么？以2^5为例。我们可以这样加快计算速度：</p>
<p>( 2^2 ) <em> (2^2) </em> 2  –&gt;  (2^2)^2 * 2。</p>
<p>这样的式子在计算机中就有优势，只需要保留(2 ^ 2)的值并不断利用更新下去。这也是为什么会把幂数转换为二进制的原因。<br>当然，本文不仅仅是介绍这个，好戏好在后头。这个算法是很多其他测试素数算法的雏形。</p>
<h2 id="引入一些抽象">引入一些抽象</h2><p>至今还没有什么奇妙的东西，但我们发现将一个数进行幂次提升实际上是将这个数对自己相乘若干次而得到。同样这可以运用在相加运算上。譬如2 * 5 可以是这样来算：2+2+2+2+2。</p>
<p>其实我们可以将前面的算法程序改造的更加通用，可以用于相乘或是相加。对此我们只需要改动几个地方。<br>对于当前的代码实现，我们把y作为相乘操作的标示，即1。如果我们要把程序用作相加操作，那么我们就需要把它设为0。那么我们就可以把这个变量提到函数的传递参数中。</p>
<p>第二步，我们应该提供一个能够进行相乘或相加的函数。这个函数应当能够进行二项运算，如带有两项参数的函数。而这个函数也必须遵从以下规则：它必须有相关性（associative）， a <em> ( b </em> c ) = ( a <em> b ) </em> c。当然，结果的类型也必须是和输入的参数类型一致。</p>
<p>幸运的是相乘、相加操作都是相关性操作，因此我们可以把他们封装成函数传递给power算法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">power</span>(<span class="params">x, n, id, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = id;</span><br><span class="line">  <span class="keyword">while</span> ( n &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">    t = n % <span class="number">2</span>;</span><br><span class="line">    n = <span class="built_in">Math</span>.floor(n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> ( t === <span class="number">1</span> ) &#123;</span><br><span class="line">      res = f(res, x);</span><br><span class="line">    &#125;</span><br><span class="line">    x = f(x, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候我们可以这样来算想2^10：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power(<span class="number">2</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a * b;&#125;); <span class="comment">// ==&gt; 1024</span></span><br></pre></td></tr></table></figure>
<p>正如你所看到，我们传递1作为我们的标示，我们也传递了计算两数相乘的函数，不过如此。</p>
<p>如果我们想计算2*10，同理，我们就传递标示0和相加函数，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power(<span class="number">2</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a + b;&#125;); <span class="comment">// ==&gt; 20</span></span><br></pre></td></tr></table></figure>
<p>要记住，我们的算法只对关联性操作有效，如果是减法就不行，比如： 10 - ( 5 - 3 ) = 8，而 ( 10 -  5 ) - 3  = 2。</p>
<h2 id="更多的抽象">更多的抽象</h2><p>从数学的角度而言，这个算法能够兼容任何关联性运算的代数结构，换而言之，它能够用作于半群（semigroup）。那什么是半群呢？</p>
<p>给定一个半群S，在这个集合中进行关联性的二项运算 • ，使得： x • (y • z) = (x • y) • z  ; x, y, z ∈ S</p>
<p>当然，这个集合必须有一个单位元（identity element），能够是这个集合成为含幺半群（Monoid）:</p>
<p>给定一个含幺半群M，e为其单位元，在这个集合中进行关联性的二项运算 • ，使得 e • x = x • e = x ； x ∈ M。</p>
<p>想想看当今我们现实工作中有没有运算结构能够满足之前给定的条件？是的，比如说要把一个字符串进行重复性的叠加，那么空字符就如同单位元。如果我们想要重复一个字符串n次，那么我们可以建构如下的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b; <span class="comment">// append stirng b to a in JS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power(<span class="string">'ab'</span>, <span class="number">12</span>, <span class="string">''</span>, repeat) <span class="comment">// ==&gt; abababababababababababab</span></span><br></pre></td></tr></table></figure>
<p>现在考虑一下阵列（array）或是链表（list）。同样，当我们想要重复n次某个阵列来建构我们想要的阵列，我们也可以用这个算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.concat(b); <span class="comment">// append array b to a in JS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power([<span class="string">'a'</span>,<span class="number">1</span>], <span class="number">5</span>, [], repeat) <span class="comment">// ==&gt;; [ 'a', 1, 'a', 1, 'a', 1, 'a', 1, 'a', 1 ]</span></span><br></pre></td></tr></table></figure>
<p>正如你所看到，这个算法看起来仅仅是针对重复计算某个数字，经我们改造后可以用到这么多场景，是不是奇妙？</p>
<h2 id="Further_Reading">Further Reading</h2><p>The power algorithm as implemented here is based on <a href="http://www-cs-faculty.stanford.edu/%7Euno/taocp.html" target="_blank" rel="external">TAOCP</a>, Vol II, section 4.6.3.</p>
<p>The whole explanation of how this works can be found in TAOCP or in the book <a href="http://shoup.net/ntb/" target="_blank" rel="external">A Computational Introduction to Number Theory and Algebra</a>. The PDF of the book is freely available on the author’s website. Look into section “Computing with large integers - The repeated squaring algorithm”.</p>
<p>If you would like to learn about several uses for this algorithm and some more theory behind it, then consult the book called <a href="http://www.amazon.com/Elements-Programming-Alexander-Stepanov/dp/032163537X" target="_blank" rel="external">Elements of Programming</a>. This book is great in the way it defines the different types of functions, and how it uses the type system to be sure that the function is actually associative, binary, and so on. The author is the designer of C++ STL, so while the concerns of the book might seem very theoretical, then can be directly applied in OOP programs.</p>
<p>The quotes about Semigroups and Monoids are from the book <a href="http://www.amazon.com/Handbook-Computational-Discrete-Mathematics-Applications/dp/1584883723/" target="_blank" rel="external">Handbook of Computational Group Theory</a>. A very interesting book if you are into CGT.</p>
<p>If you want to learn more about Monoids and their implementations this chapter from <em>Learn You a Haskell</em> has a very nice introduction to <a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids" target="_blank" rel="external">Functors, Applicative Functors and Monoids</a>.</p>
<p>It could be an interesting exercise to implement these concepts using say PHP and OOP, or for the PHP non lovers, in some other imperative language of your choice.</p>
</div><div class="tags"><a href="/tags/algorithm/">algorithm</a></div><div class="categories">分类于<a href="/categories/Algorithm/">Algorithm</a></div><div class="page-navigator"><a href="/2015/01/27/-T-Creating-a-wildly-successful-blog/" class="pre">上一页</a><a href="/2014/09/22/object-inheritence-in-javascript/" class="next">下一页</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Collective-Intelligence/">Collective Intelligence</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Thoughts/">Thoughts</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/artificial-intelligence/" style="font-size: 15px;">artificial intelligence</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/10/23/Quick Walk through Recommender systems and Memory-based Collaborative Filtering/">Quick Walk through Recommender Systems and Memory-based Collaborative Filtering</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/27/-T-Creating-a-wildly-successful-blog/">创建一个成功的个人博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/23/-e6-b1-82-e5-b9-82-e7-ae-97-e6-b3-95/">求幂算法的延伸运用</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/22/object-inheritence-in-javascript/">Object Inheritence in Javascript</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/21/javascript-memory-management/">Javascript Memory Management</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/18/javascript-read-notes/">Javascript Read Notes</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/14/kmp-knuth-morris-pratt/">KMP (Knuth-Morris-Pratt)</a></li></ul></div><div class="widget"><div class="widget-title">友情链接</div><ul><a href="http://example1.com/" title="site-name 1" target="_blank" rel="external">site-name 1</a></ul><ul><a href="http://example2.com/" title="site-name 2" target="_blank" rel="external">site-name 2</a></ul><ul><a href="http://example3.com/" title="site-name 3" target="_blank" rel="external">site-name 3</a></ul></div></div></div></div><script src="/js/highlight.pack.js" type="text/javascript"></script><script>hljs.initHighlightingOnLoad();
</script><div id="footer">© <a href="/" real="nofollow">斯是陋室. </a>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a>Theme by<a rel="nofollow" target="_blank" href="https://chopstack.com">Cho</a></div></div></body><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>$(document).ready(function() {
  $("img").wrap(function() {
    if ($(this).hasClass('nofancybox')) return;
    return '<a href="' + $(this).attr("src") + '" rel="group" />'});
});</script><script>$(document).ready(function() {
  $("a[href$='.jpg'],a[href$='.png'],a[href$='.gif']").attr('rel', 'gallery').fancybox({
   helpers : {
   title: { type: 'inside'}
   },
   afterLoad: function(){
   this.title = this.title + ' ' + $(this.element).find('img').attr('alt');
   }
 });
});
</script></html>